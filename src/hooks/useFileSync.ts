/**
 * â”€â”€â”€ useFileSync â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 * Syncs the Vectra element tree to the WebContainer VFS.
 *
 * PHASE E: Framework Switcher
 * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 * All VFS paths and code generators now branch on `framework` from useProject().
 * The two supported frameworks produce entirely different file structures:
 *
 *   NEXT.JS (framework === 'nextjs')
 *   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 *   components/[Name].tsx        custom_code component files
 *   app/page.tsx                 Home page
 *   app/[slug]/page.tsx          Additional pages
 *   app/layout.tsx               Root layout (with Navbar if 2+ pages)
 *   components/Navbar.tsx        Multi-page navigation
 *   app/api/[path]/route.ts      API routes (Phase D, framework-agnostic)
 *   data/project.json            Serialized project for ZIP
 *   tailwind-gen.js              JIT ghost file (root)
 *   tailwind.config.js           Next.js content paths
 *
 *   VITE (framework === 'vite')
 *   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 *   src/components/[Name].tsx    custom_code component files
 *   src/App.tsx                  BrowserRouter + Routes (all pages)
 *   src/data/project.json        Serialized project for ZIP
 *   src/tailwind-gen.js          JIT ghost file (src/)
 *   tailwind.config.js           Vite content paths
 *
 * PRESERVED FROM PRIOR PHASES:
 *   â€¢ Phase 4: All dirty-check guards (ref equality, drag suppression,
 *              concurrency, debounce, per-file content guard)
 *   â€¢ Phase C: buildTailwindConfig(), toPascalCase(), wrapWithImports()
 *   â€¢ Phase D: Section F (API routes), prevApiRoutesRef
 */

import { useEffect, useRef } from 'react';
import { useProject } from '../context/ProjectContext';
import { useUI } from '../context/UIContext';
import { useContainer } from '../context/ContainerContext';
import {
  generateNextPage,
  generateRootLayout,
  generateNextNavbar,
  slugToNextPath,
  generateApiRouteFile,
  apiRouteToVfsPath,
  generateProjectCode,
  deduplicatePageSlugs,
} from '../utils/codeGenerator';
import type { VectraProject } from '../types';

// â”€â”€â”€ HELPERS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

/**
 * PascalCase converter â€” mirrors generateNextPage() exactly.
 * MUST NOT diverge â€” component file names must match import paths.
 */
const toPascalCase = (raw: string): string => {
  const cleaned = raw
    .replace(/[^a-zA-Z0-9\s]/g, ' ')
    .replace(/\s+/g, ' ')
    .trim()
    .split(' ')
    .map(word => word.charAt(0).toUpperCase() + word.slice(1))
    .join('');
  return /^[A-Z]/.test(cleaned) ? cleaned : 'Component' + cleaned;
};

/**
 * wrapWithImports â€” Next.js variant
 * 'use client' is the first line (required for App Router).
 */
const wrapWithImportsNext = (rawCode: string): string =>
  `'use client';

import React, { useState, useEffect, useRef } from 'react';
import * as Lucide from 'lucide-react';
import { motion, AnimatePresence } from 'framer-motion';
import { cn } from '@/lib/utils';

/* â”€â”€â”€ Auto-generated by Vectra AI â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
${rawCode}
`;

/**
 * wrapWithImports â€” Vite variant
 * No 'use client'. Path is '../lib/utils' (src/components/ is 2 levels deep).
 */
const wrapWithImportsVite = (rawCode: string): string =>
  `import React, { useState, useEffect, useRef } from 'react';
import * as Lucide from 'lucide-react';
import { motion, AnimatePresence } from 'framer-motion';
import { cn } from '../lib/utils';

/* â”€â”€â”€ Auto-generated by Vectra AI â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
${rawCode}
`;

/**
 * buildViteAppTsx
 * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 * Generates src/App.tsx content for the Vite/React Router output.
 */
const buildViteAppTsx = (
  elements: VectraProject,
  pages: Array<{ id: string; name: string; slug: string; rootId: string }>
): string => {
  const customEls = Object.values(elements).filter(
    el => el.type === 'custom_code' && typeof el.code === 'string' && el.code.trim().length > 0
  );

  const componentImports = customEls.map(el => {
    const name = toPascalCase(el.name?.trim() || el.id);
    return `import ${name} from './components/${name}';`;
  }).join('\n');

  const pageImports = pages.map(p => {
    const name = p.name.replace(/[^a-zA-Z0-9]/g, '') || 'Home';
    return `import ${name}Page from './pages/${name}Page';`;
  }).join('\n');

  const routes = pages.map(p => {
    const name = p.name.replace(/[^a-zA-Z0-9]/g, '') || 'Home';
    return `        <Route path="${p.slug}" element={<${name}Page />} />`;
  }).join('\n');

  return `import React from 'react';
import { BrowserRouter, Routes, Route } from 'react-router-dom';
${pageImports}
${componentImports}

export default function App() {
  return (
    <BrowserRouter>
      <Routes>
${routes}
      </Routes>
    </BrowserRouter>
  );
}
`;
};

/**
 * buildNextTailwindConfig â€” Next.js version
 */
const buildNextTailwindConfig = (theme: {
  primary: string; secondary: string; accent: string; radius: string; font: string;
}): string =>
  `/** @type {import('tailwindcss').Config} */
module.exports = {
  darkMode: 'class',
  content: [
    './app/**/*.{js,ts,jsx,tsx,mdx}',
    './components/**/*.{js,ts,jsx,tsx,mdx}',
    './tailwind-gen.js',
    './data/project.json',
  ],
  theme: {
    extend: {
      colors: { primary: '${theme.primary}', secondary: '${theme.secondary}', accent: '${theme.accent}' },
      borderRadius: { DEFAULT: '${theme.radius}' },
      fontFamily: { sans: ['${theme.font}', 'sans-serif'] },
    },
  },
  plugins: [],
}`;

/**
 * buildViteTailwindConfig â€” Vite version
 */
const buildViteTailwindConfig = (theme: {
  primary: string; secondary: string; accent: string; radius: string; font: string;
}): string =>
  `/** @type {import('tailwindcss').Config} */
export default {
  darkMode: 'class',
  content: [
    './index.html',
    './src/**/*.{js,ts,jsx,tsx}',
    './src/tailwind-gen.js',
    './src/data/project.json',
  ],
  theme: {
    extend: {
      colors: { primary: '${theme.primary}', secondary: '${theme.secondary}', accent: '${theme.accent}' },
      borderRadius: { DEFAULT: '${theme.radius}' },
      fontFamily: { sans: ['${theme.font}', 'sans-serif'] },
    },
  },
  plugins: [],
}`;

// â”€â”€â”€ HOOK â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

export const useFileSync = () => {
  const { elements, pages, theme, apiRoutes, framework } = useProject();
  const { interaction } = useUI();
  const { writeFile, removeFile, status, instance } = useContainer();

  // â”€â”€ Dirty-check refs â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const prevElementsRef = useRef<VectraProject>({});
  const prevPageStructuresRef = useRef<Record<string, string>>({});
  const prevThemeKeyRef = useRef<string>('');
  const prevClassesRef = useRef<string>('');
  const prevPageCountRef = useRef<number>(0);
  // Phase D: API route dirty-check. Value format: "updatedAt::vfsPath"
  const prevApiRoutesRef = useRef<Record<string, string>>({});

  const syncedFiles = useRef<Map<string, string>>(new Map());
  const isSyncing = useRef<boolean>(false);
  // NS-7 FIX: interaction in the dep array caused the sync effect to re-run at 60fps
  // during drag (setInteraction produces a new object every pointermove). The early-return
  // guard was hit correctly but the debounce timer was still reset 60Ã—/second, starving
  // the VFS for the entire drag duration (> 800ms). Now use a ref mirrored by a separate
  // stable effect, and remove interaction from the sync dep array entirely.
  const interactionRef = useRef(interaction);
  useEffect(() => { interactionRef.current = interaction; }, [interaction]);

  useEffect(() => {
    // â”€â”€ Guard 1: VFS not ready â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    if (status !== 'ready' || !instance) return;

    // â”€â”€ Guard 2: Suppress during 60fps drag/resize (NS-7: reads ref, not dep) â”€â”€â”€â”€
    if (interactionRef.current?.type === 'MOVE' || interactionRef.current?.type === 'RESIZE') return;

    // â”€â”€ Guard 3: Early-exit if nothing changed â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    if (elements === prevElementsRef.current && pages.length === prevPageCountRef.current) return;

    const sync = async () => {
      if (isSyncing.current) return;
      isSyncing.current = true;

      // â”€â”€ Resolve framework-specific path constants â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      const isNext = framework === 'nextjs';
      const componentDir = isNext ? 'components' : 'src/components';
      const projectJsonPath = isNext ? 'data/project.json' : 'src/data/project.json';
      const tailwindGenPath = isNext ? 'tailwind-gen.js' : 'src/tailwind-gen.js';

      try {
        const prevElements = prevElementsRef.current;

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // SECTION A â€” COMPONENT FILES
        // custom_code nodes â†’ [componentDir]/[ComponentName].tsx
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // H-3 FIX: the previous 2-level manual loop reached only:
        //   page-root â†’ webpage/canvas â†’ direct children
        // Any custom_code node nested inside a container, section, card, etc.
        // was never added to allChildIds â€” its file was never written to VFS.
        // At dev-server start Next.js throws `Module not found` with no editor error.
        // Replace with a proper recursive walk over the full page subtree.
        const allChildIds = new Set<string>();
        const walkNode = (id: string) => {
          if (allChildIds.has(id)) return; // cycle-guard
          allChildIds.add(id);
          (elements[id]?.children || []).forEach(walkNode);
        };
        for (const page of pages) {
          walkNode(page.rootId);
        }

        for (const nodeId of allChildIds) {
          const currentNode = elements[nodeId];
          const prevNode = prevElements[nodeId];
          if (currentNode === prevNode) continue;

          if (
            currentNode?.type === 'custom_code' &&
            typeof currentNode.code === 'string' &&
            currentNode.code.trim().length > 0
          ) {
            const componentName = toPascalCase(currentNode.name?.trim() || currentNode.id);
            const filePath = `${componentDir}/${componentName}.tsx`;
            const content = isNext
              ? wrapWithImportsNext(currentNode.code)
              : wrapWithImportsVite(currentNode.code);

            if (syncedFiles.current.get(filePath) !== content) {
              await writeFile(filePath, content);
              syncedFiles.current.set(filePath, content);
              console.log(`ğŸ“¦ [Vectra] Component â†’ ${filePath}`);
            }
          }
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // SECTION B â€” PAGE / APP FILES
        //
        // NEXT.JS: Per-page app/[slug]/page.tsx + app/layout.tsx
        // VITE:    Single src/App.tsx with BrowserRouter + Routes
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        let anyPageChanged = false;

        if (isNext) {
          // â”€â”€ B-NEXT: Per-page generation â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
          const safePages = deduplicatePageSlugs(pages);
          const currentSafePageIds = new Set(safePages.map(p => p.id));

          // Detect + remove deleted pages and detect renames
          for (const [prevId, prevEntry] of Object.entries(prevPageStructuresRef.current)) {
            if (prevId === '__vite_pages__') continue;

            const prevPath = prevEntry.split('::')[0];
            const correspondingSafePage = safePages.find(p => p.id === prevId);
            const currentPath = correspondingSafePage ? slugToNextPath(correspondingSafePage.slug) : null;

            // If the page was deleted OR renamed (path changed), remove the old file
            if (!currentSafePageIds.has(prevId) || (currentPath && prevPath !== currentPath)) {
              if (prevPath && prevPath !== 'app/page.tsx' && prevPath !== 'src/App.tsx') {
                try {
                  await removeFile(prevPath);
                  syncedFiles.current.delete(prevPath);
                  console.log(`ğŸ—‘ï¸ [Vectra] Deleted page file â†’ ${prevPath}`);
                } catch {
                  // File may not exist yet
                }
              }
              if (!currentSafePageIds.has(prevId)) {
                delete prevPageStructuresRef.current[prevId];
              }
            }
          }

          for (const page of safePages) {
            // H-1 FIX: the previous structureKey used Object.keys(props).length
            // per direct child â€” a count that never changes on text edits, style
            // value changes, src changes, or mutations to nested nodes.
            // Result: page file was never re-synced for the most common editor ops.
            //
            // Replacement: recursive subtree walk accumulating id + full node JSON.
            // elements is replaced immutably on every edit, so any descendant change
            // produces a new object ref â†’ new JSON.stringify â†’ different structureKey.
            // Cost: JSON.stringify is O(subtree) but paid once per changed page per
            // 1s debounce tick â€” never on the 60fps hot path.
            const collectSubtreeForKey = (id: string, out: string[]) => {
              const node = elements[id];
              if (!node) return;
              out.push(`${id}:${JSON.stringify(node)}`);
              (node.children || []).forEach(cid => collectSubtreeForKey(cid, out));
            };
            const subtreeFragments: string[] = [];
            collectSubtreeForKey(page.rootId, subtreeFragments);
            const structureKey = subtreeFragments.join('|');

            const filePath = slugToNextPath(page.slug);
            const prevEntry = prevPageStructuresRef.current[page.id];
            const prevStructure = prevEntry?.split('::')[1];

            // Same path and same structure -> skip
            if (prevEntry && prevEntry.startsWith(filePath + '::') && prevStructure === structureKey) {
              continue;
            }

            anyPageChanged = true;
            let pageContent: string;
            try {
              pageContent = generateNextPage(page, elements);
            } catch {
              pageContent = `export default function ${page.name.replace(/\s/g, '')}Page() { return <main className="p-8">Page Error</main>; }`;
            }

            if (syncedFiles.current.get(filePath) !== pageContent) {
              await writeFile(filePath, pageContent);
              syncedFiles.current.set(filePath, pageContent);
              console.log(`ğŸ“„ [Vectra] Page â†’ ${filePath}`);
            }
            prevPageStructuresRef.current[page.id] = `${filePath}::${structureKey}`;
          }

          // â”€â”€ B-NEXT: layout.tsx + Navbar â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
          const pageCountChanged = safePages.length !== prevPageCountRef.current;
          if (pageCountChanged || anyPageChanged) {
            const layoutContent = generateRootLayout(safePages, theme);
            if (syncedFiles.current.get('app/layout.tsx') !== layoutContent) {
              await writeFile('app/layout.tsx', layoutContent);
              syncedFiles.current.set('app/layout.tsx', layoutContent);
              console.log('[Vectra] Layout â†’ app/layout.tsx');
            }
            if (safePages.length > 1) {
              const navContent = generateNextNavbar(safePages);
              if (syncedFiles.current.get('components/Navbar.tsx') !== navContent) {
                await writeFile('components/Navbar.tsx', navContent);
                syncedFiles.current.set('components/Navbar.tsx', navContent);
                console.log('[Vectra] Navbar â†’ components/Navbar.tsx');
              }
            }
          }

        } else {
          // â”€â”€ B-VITE: Single App.tsx with BrowserRouter â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
          const pagesKey = JSON.stringify(pages.map(p => p.id));
          const structureChanged = pagesKey !== (prevPageStructuresRef.current['__vite_pages__'] || '');

          if (structureChanged || pages.length !== prevPageCountRef.current) {
            anyPageChanged = true;

            // Generate page component files via Vite generator
            const { files: viteFiles } = generateProjectCode(elements, pages, []);
            for (const [filePath, content] of Object.entries(viteFiles)) {
              if (syncedFiles.current.get(filePath) !== content) {
                await writeFile(filePath, content);
                syncedFiles.current.set(filePath, content);
                console.log(`ğŸ“„ [Vectra] Vite page â†’ ${filePath}`);
              }
            }

            // Write the top-level App.tsx
            const appContent = buildViteAppTsx(elements, pages);
            if (syncedFiles.current.get('src/App.tsx') !== appContent) {
              await writeFile('src/App.tsx', appContent);
              syncedFiles.current.set('src/App.tsx', appContent);
              console.log('[Vectra] App â†’ src/App.tsx');
            }

            prevPageStructuresRef.current['__vite_pages__'] = pagesKey;
          }
        }

        prevPageCountRef.current = pages.length;

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // SECTION C â€” PROJECT JSON
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        const projectData = { pages, elements, framework };
        const jsonString = JSON.stringify(projectData, null, 2);
        if (syncedFiles.current.get(projectJsonPath) !== jsonString) {
          await writeFile(projectJsonPath, jsonString);
          syncedFiles.current.set(projectJsonPath, jsonString);
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // SECTION D â€” TAILWIND GHOST CLASSES (JIT scanner)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        const canvasClasses = Object.values(elements)
          .map(el => (el.props as any)?.className || '').join(' ');
        const codeClasses = Object.values(elements)
          .filter(el => el.type === 'custom_code' && el.code)
          .map(el => el.code!).join(' ');
        const allClasses = `${canvasClasses} ${codeClasses}`.trim();

        if (allClasses !== prevClassesRef.current) {
          const ghostContent = `// Auto-generated for Tailwind JIT\nexport const classes = "${allClasses.replace(/"/g, "'")}";`;
          if (syncedFiles.current.get(tailwindGenPath) !== ghostContent) {
            await writeFile(tailwindGenPath, ghostContent);
            syncedFiles.current.set(tailwindGenPath, ghostContent);
          }
          prevClassesRef.current = allClasses;
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // SECTION E â€” TAILWIND CONFIG + LAYOUT (theme changes)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        const themeKey = JSON.stringify(theme);
        if (themeKey !== prevThemeKeyRef.current) {
          const twContent = isNext
            ? buildNextTailwindConfig(theme)
            : buildViteTailwindConfig(theme);
          await writeFile('tailwind.config.js', twContent);

          if (isNext) {
            const layoutContent = generateRootLayout(pages, theme);
            await writeFile('app/layout.tsx', layoutContent);
            syncedFiles.current.set('app/layout.tsx', layoutContent);
          }

          prevThemeKeyRef.current = themeKey;
          console.log('[Vectra] Theme synced â†’ tailwind.config.js');
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // SECTION F â€” API ROUTE FILES (Phase D â€” framework-agnostic)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        {
          const currentRouteIds = new Set(apiRoutes.map(r => r.id));

          // Detect + remove deleted routes
          for (const [prevId, prevEntry] of Object.entries(prevApiRoutesRef.current)) {
            if (!currentRouteIds.has(prevId)) {
              const vfsPath = prevEntry.split('::')[1];
              if (vfsPath) {
                try {
                  await removeFile(vfsPath);
                  console.log(`ğŸ—‘ï¸ [Vectra] Deleted route â†’ ${vfsPath}`);
                } catch {
                  // File may not exist yet â€” safe to ignore
                }
              }
              delete prevApiRoutesRef.current[prevId];
            }
          }

          // Write/update dirty routes
          for (const route of apiRoutes) {
            const prevEntry = prevApiRoutesRef.current[route.id];
            const prevUpdatedAt = prevEntry?.split('::')[0];
            if (prevUpdatedAt === route.updatedAt) continue;

            const vfsPath = apiRouteToVfsPath(route.path);
            const fileContent = generateApiRouteFile(route);
            if (syncedFiles.current.get(vfsPath) !== fileContent) {
              await writeFile(vfsPath, fileContent);
              syncedFiles.current.set(vfsPath, fileContent);
              console.log(`ğŸ›£ï¸ [Vectra] API route â†’ ${vfsPath}`);
            }
            prevApiRoutesRef.current[route.id] = `${route.updatedAt}::${vfsPath}`;
          }
        }

        // Advance the prev-ref checkpoint
        prevElementsRef.current = elements;

      } catch (e) {
        console.error('[useFileSync] Sync error:', e);
      } finally {
        isSyncing.current = false;
      }
    };

    // S-2 FIX: smart debounce â€” delay varies by change type to prevent starvation.
    //
    //   AI generation   â†’ node count changes rapidly â†’ 800ms (let it settle)
    //   Structural edit â†’ children[] or type changed â†’ 600ms (standard structural)
    //   Style edit only â†’ same nodes, same count    â†’ 250ms (fast for sliders)
    //
    // The old flat 600ms timer reset on every AI setElements call, starving the VFS
    // for 3+ seconds while the AI was running a multi-step generation sequence.
    const prevNodeCount = prevElementsRef.current ? Object.keys(prevElementsRef.current).length : 0;
    const currNodeCount = Object.keys(elements).length;
    const nodeCountChanged = currNodeCount !== prevNodeCount;

    let debounceMs: number;
    if (nodeCountChanged) {
      // Could be AI adding nodes, drag-drop template, etc. â€” let it settle
      debounceMs = 800;
    } else if (elements !== prevElementsRef.current) {
      // Same node count but references changed â€” could be style slider
      debounceMs = 250;
    } else {
      debounceMs = 600; // pages/apiRoutes/theme change
    }

    const timer = setTimeout(sync, debounceMs);
    return () => clearTimeout(timer);

  }, [elements, pages, apiRoutes, framework, status, instance, writeFile, removeFile, theme]); // interaction removed â€” read via interactionRef
};
