/**
 * â”€â”€â”€ useFileSync â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 * Syncs the Vectra element tree to the WebContainer VFS.
 *
 * PHASE 4 OPTIMISATIONS: Reference-Equality Dirty Checking
 * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 * React's immutable state updates mean that if a node reference hasn't changed
 * (currentNode === prevNode), the node's content hasn't changed either.
 *
 * Previous approach: JSON.stringify(entire project) â†’ compare â†’ write all files.
 *   Cost: O(N) always. On a 5 000-node project â†’ ~8ms per 500ms tick.
 *
 * New approach:
 *  1. Object-level ref check on `elements` itself: if the same reference,
 *     skip the tick entirely â€” accounts for drag-induced re-renders.
 *  2. Per-node ref check: walk only children of the active page.
 *     Only nodes whose reference changed are re-generated and written.
 *  3. Structure string (rootIds JSON) compared for App.tsx regeneration.
 *   Cost: O(D) where D = dirty nodes. Typically 0â€“1 per edit.
 *
 * Subscriptions
 * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 * â€¢ useProject()  â€” elements, pages (project data only)
 * â€¢ useUI()       â€” interaction (to suppress sync during 60fps drag)
 * NOT useEditor() â€” avoids the heavy combined subscription that would
 *                   re-run this effect on every UI state change.
 */

import { useEffect, useRef } from 'react';
import { useProject } from '../context/ProjectContext';
import { useUI } from '../context/UIContext';
import { useContainer } from '../context/ContainerContext';
import type { VectraProject } from '../types';

// â”€â”€â”€ HELPERS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

/**
 * Converts any raw string into a valid PascalCase React component name.
 * e.g. "hero section!" â†’ "HeroSection"  |  "" â†’ "Component"
 */
const toPascalCase = (raw: string): string => {
  const cleaned = raw
    .replace(/[^a-zA-Z0-9\s]/g, ' ')
    .replace(/\s+/g, ' ')
    .trim()
    .split(' ')
    .map(word => word.charAt(0).toUpperCase() + word.slice(1))
    .join('');
  return /^[A-Z]/.test(cleaned) ? cleaned : 'Component' + cleaned;
};

/**
 * Wraps raw AI JSX code with production-ready ES module imports.
 * The AI generates code without imports (React/Lucide/motion are globals in the
 * sandbox). We reattach them here for the real .tsx file on disk.
 */
const wrapWithImports = (rawCode: string): string =>
  `import React, { useState, useEffect, useRef } from 'react';
import * as Lucide from 'lucide-react';
import { motion, AnimatePresence } from 'framer-motion';
import { cn } from '../lib/utils';

/* â”€â”€â”€ Auto-generated by Vectra AI â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
${rawCode}
`;

/**
 * Generates the App.tsx content from the current set of custom-code elements.
 */
const buildAppTsx = (elements: VectraProject): string => {
  const customEls = Object.values(elements).filter(
    el => el.type === 'custom_code' && typeof el.code === 'string' && el.code.trim().length > 0
  );

  let imports = `import React from 'react';\n`;
  let jsx = '';

  if (customEls.length > 0) {
    for (const el of customEls) {
      const name = toPascalCase(el.name?.trim() || el.id);
      imports += `import ${name} from './components/${name}';\n`;
      jsx += `      <${name} />\n`;
    }
  } else {
    jsx = `      <div className="flex items-center justify-center min-h-screen text-zinc-500 font-mono text-sm">
        No components generated yet â€” open the AI bar and build something!
      </div>\n`;
  }

  return `${imports}
export default function App() {
  return (
    <div className="min-h-screen bg-black text-white w-full overflow-x-hidden">
${jsx}    </div>
  );
}
`;
};

/**
 * Builds the tailwind.config.js content from the current theme.
 */
const buildTailwindConfig = (theme: { primary: string; secondary: string; accent: string; radius: string; font: string }): string =>
  `/** @type {import('tailwindcss').Config} */
export default {
  darkMode: 'class',
  content: [
    "./index.html",
    "./src/**/*.{js,ts,jsx,tsx}",
    "./src/data/project.json",
    "./src/tailwind-gen.js"
  ],
  theme: {
    extend: {
      colors: {
        primary:   '${theme.primary}',
        secondary: '${theme.secondary}',
        accent:    '${theme.accent}',
      },
      borderRadius: {
        DEFAULT: '${theme.radius}',
      },
      fontFamily: {
        sans: ['${theme.font}', 'sans-serif'],
      },
    },
  },
  plugins: [],
}`;

// â”€â”€â”€ HOOK â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

export const useFileSync = () => {
  // Narrow subscriptions: only re-run when project data or drag state changes.
  // useUI() instead of useEditor() avoids the heavy combined subscription.
  const { elements, pages, theme } = useProject();
  const { interaction } = useUI();
  const { writeFile, status, instance } = useContainer();

  // â”€â”€ Dirty-check refs â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // prevElementsRef stores the previous elements object reference.
  // If elements === prevElementsRef.current, the entire tick is skipped.
  const prevElementsRef = useRef<VectraProject>({});
  const prevStructureRef = useRef<string>('');
  const prevThemeKeyRef = useRef<string>('');
  const prevClassesRef = useRef<string>('');

  // Per-file content guard: only write files whose content string changed.
  const syncedFiles = useRef<Map<string, string>>(new Map());

  // Concurrency guard: if a sync is in progress, skip the overlapping tick.
  const isSyncing = useRef<boolean>(false);

  useEffect(() => {
    // â”€â”€ Guard 1: VFS not ready â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    if (status !== 'ready' || !instance) return;

    // â”€â”€ Guard 2: Suppress during active drag/resize (runs at 60fps) â”€â”€â”€â”€
    // Drag state is handled by handleInteractionMove which calls
    // updateProject(els, skipHistory=true) â€” elements reference changes
    // every frame during drag. We must not serialize the tree here.
    if (interaction?.type === 'MOVE' || interaction?.type === 'RESIZE') return;

    // â”€â”€ Guard 3: Early-exit if nothing changed (object ref equality) â”€â”€â”€
    // After a drag ends, elements ref is the same as before the drag
    // (only the dragged node changes). Per-node ref check below handles that.
    // This guard catches pure UI changes (panel open, zoom) that leave
    // elements completely untouched.
    if (elements === prevElementsRef.current) return;

    const sync = async () => {
      if (isSyncing.current) return;
      isSyncing.current = true;

      try {
        const rootIds = elements['page-home']?.children || [];
        const prevElements = prevElementsRef.current;

        // â”€â”€ A. PER-NODE DIRTY CHECK: component files â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        // Walk only the direct children of the active page.
        // For each, compare the node reference to its previous value.
        // O(D) where D = number of dirty nodes (usually 0 or 1).
        for (const rootId of rootIds) {
          const currentNode = elements[rootId];
          const prevNode = prevElements[rootId];

          // ðŸš€ Reference equality: if same object, skip entirely.
          if (currentNode === prevNode) continue;

          // Node is dirty â€” only write custom_code elements to disk.
          if (
            currentNode &&
            currentNode.type === 'custom_code' &&
            typeof currentNode.code === 'string' &&
            currentNode.code.trim().length > 0
          ) {
            const componentName = toPascalCase(currentNode.name?.trim() || currentNode.id);
            const filePath = `src/components/${componentName}.tsx`;
            const content = wrapWithImports(currentNode.code);

            // Per-file content guard: only write if content changed
            if (syncedFiles.current.get(filePath) !== content) {
              await writeFile(filePath, content);
              syncedFiles.current.set(filePath, content);
              console.log(`ðŸ“¦ [Vectra] Synthesized â†’ ${filePath}`);
            }
          }
        }

        // â”€â”€ B. APP STRUCTURE (App.tsx) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        // Only regenerate if the list of root children changed.
        // JSON.stringify on an array of IDs is cheap (strings only).
        const currentStructure = JSON.stringify(rootIds);
        if (currentStructure !== prevStructureRef.current) {
          const appContent = buildAppTsx(elements);
          const prevApp = syncedFiles.current.get('src/App.tsx');
          if (prevApp !== appContent) {
            await writeFile('src/App.tsx', appContent);
            syncedFiles.current.set('src/App.tsx', appContent);
            console.log('[Sync] Updated App.tsx structure');
          }
          prevStructureRef.current = currentStructure;
        }

        // â”€â”€ C. PROJECT JSON (for download) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        // Only write when elements actually changed (already guaranteed
        // by Guard 3 above, but keep for explicitness).
        const projectData = { pages, elements };
        const jsonString = JSON.stringify(projectData, null, 2);
        if (syncedFiles.current.get('src/data/project.json') !== jsonString) {
          await writeFile('src/data/project.json', jsonString);
          syncedFiles.current.set('src/data/project.json', jsonString);
        }

        // â”€â”€ D. TAILWIND GHOST CLASSES (className scanner) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        // Tailwind JIT scans this file for all className strings.
        const canvasClasses = Object.values(elements)
          .map(el => (el.props as any)?.className || '')
          .join(' ');
        const codeClasses = Object.values(elements)
          .filter(el => el.type === 'custom_code' && el.code)
          .map(el => el.code!)
          .join(' ');
        const allClasses = `${canvasClasses} ${codeClasses}`.trim();

        if (allClasses !== prevClassesRef.current) {
          const ghostContent = `// Auto-generated for Tailwind JIT â€” do not edit\nexport const classes = "${allClasses.replace(/"/g, "'")}";`;
          const ghostPath = 'src/tailwind-gen.js';
          if (syncedFiles.current.get(ghostPath) !== ghostContent) {
            await writeFile(ghostPath, ghostContent);
            syncedFiles.current.set(ghostPath, ghostContent);
          }
          prevClassesRef.current = allClasses;
        }

        // â”€â”€ E. TAILWIND CONFIG (theme changes only) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        const themeKey = JSON.stringify(theme);
        if (themeKey !== prevThemeKeyRef.current) {
          const twContent = buildTailwindConfig(theme);
          await writeFile('tailwind.config.js', twContent);
          prevThemeKeyRef.current = themeKey;
        }

        // â”€â”€ Advance the prev-ref checkpoint â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        prevElementsRef.current = elements;

      } catch (e) {
        console.error('[useFileSync] Sync error:', e);
      } finally {
        isSyncing.current = false;
      }
    };

    // Debounce 600ms â€” let the user finish typing/dragging before we write.
    // Reduced from 800ms since the dirty check makes each pass much cheaper.
    const timer = setTimeout(sync, 600);
    return () => clearTimeout(timer);

    // NOTE: `theme` is intentionally included; it changes rarely but when it
    // does (tailwind config) we must not skip the tick.
  }, [elements, pages, interaction, status, instance, writeFile, theme]);
};
